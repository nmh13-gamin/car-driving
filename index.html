<!DOCTYPE html> <html> <head> <title>3D Driving Game</title> <style> body { margin: 0; overflow: hidden; } canvas { width: 100%; height: 100%; } </style> </head> <body> <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script> <script> // Scene setup const scene = new THREE.Scene(); const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); const renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); document.body.appendChild(renderer.domElement); // Lighting const ambientLight = new THREE.AmbientLight(0x404040, 1); // Soft ambient light scene.add(ambientLight); const directionalLight = new THREE.DirectionalLight(0xffffff, 1); directionalLight.position.set(50, 50, 50); scene.add(directionalLight); // Texture Loader const textureLoader = new THREE.TextureLoader(); // Player car const carTexture = textureLoader.load('https://threejs.org/examples/textures/brick_diffuse.jpg'); const carGeometry = new THREE.BoxGeometry(2, 1, 4); const carMaterial = new THREE.MeshPhongMaterial({ map: carTexture, shininess: 100 }); const car = new THREE.Mesh(carGeometry, carMaterial); car.position.y = 0.5; scene.add(car); const carPhysics = { speed: 0, maxSpeed: 0.4, acceleration: 0.015, turnSpeed: 0.03, velocityY: 0, gravity: 0.02, onGround: true, mass: 1, friction: 0.95 }; // Ground const groundTexture = textureLoader.load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg'); groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping; groundTexture.repeat.set(10, 10); const groundGeometry = new THREE.PlaneGeometry(200, 200); const groundMaterial = new THREE.MeshPhongMaterial({ map: groundTexture }); const ground = new THREE.Mesh(groundGeometry, groundMaterial); ground.rotation.x = -Math.PI / 2; scene.add(ground); // Roads const roadTexture = textureLoader.load('https://threejs.org/examples/textures/floors/FloorsCheckerboard_S_Diffuse.jpg'); roadTexture.wrapS = roadTexture.wrapT = THREE.RepeatWrapping; roadTexture.repeat.set(1, 10); const roadMaterial = new THREE.MeshPhongMaterial({ map: roadTexture }); const roadGeometry = new THREE.PlaneGeometry(12, 200); const roadGeometry2 = new THREE.PlaneGeometry(200, 12); const intersectionGeometry = new THREE.PlaneGeometry(12, 12); const roads = []; for (let x = -90; x <= 90; x += 30) { const roadV = new THREE.Mesh(roadGeometry, roadMaterial); roadV.rotation.x = -Math.PI / 2; roadV.position.set(x, 0.01, 0); roads.push(roadV); scene.add(roadV); const roadH = new THREE.Mesh(roadGeometry2, roadMaterial); roadH.rotation.x = -Math.PI / 2; roadH.position.set(0, 0.01, x); roads.push(roadH); scene.add(roadH); for (let z = -90; z <= 90; z += 30) { const intersection = new THREE.Mesh(intersectionGeometry, roadMaterial); intersection.rotation.x = -Math.PI / 2; intersection.position.set(x, 0.015, z); roads.push(intersection); scene.add(intersection); } } // Road markings const markingMaterial = new THREE.MeshPhongMaterial({ color: 0xffff00 }); const markingGeometry = new THREE.PlaneGeometry(0.5, 2); for (let x = -90; x <= 90; x += 30) { for (let z = -90; z <= 90; z += 10) { if (Math.abs(z % 30) > 5) { const markingV = new THREE.Mesh(markingGeometry, markingMaterial); markingV.rotation.x = -Math.PI / 2; markingV.position.set(x, 0.02, z); scene.add(markingV); } } } // Buildings const buildingTexture = textureLoader.load('https://threejs.org/examples/textures/brick_bump.jpg'); const buildingMaterial = new THREE.MeshPhongMaterial({ map: buildingTexture }); const buildingVariations = [ {width: 10, height: 15, depth: 10}, {width: 8, height: 20, depth: 8}, {width: 12, height: 12, depth: 12} ]; const buildings = []; for (let x = -80; x <= 80; x += 30) { for (let z = -80; z <= 80; z += 30) { if (Math.abs(x) < 15 && Math.abs(z) < 15) continue; const variation = buildingVariations[Math.floor(Math.random() * buildingVariations.length)]; const buildingGeometry = new THREE.BoxGeometry(variation.width, variation.height, variation.depth); const building = new THREE.Mesh(buildingGeometry, buildingMaterial); building.position.set(x + Math.random() * 5 - 2.5, variation.height/2, z + Math.random() * 5 - 2.5); buildings.push(building); scene.add(building); } } // Traffic Lights const lightPoleMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 }); const lightPoleGeometry = new THREE.CylinderGeometry(0.2, 0.2, 10); const lightGeometry = new THREE.BoxGeometry(1, 0.5, 0.5); const trafficLights = []; for (let x = -90; x <= 90; x += 30) { for (let z = -90; z <= 90; z += 30) { const pole = new THREE.Mesh(lightPoleGeometry, lightPoleMaterial); pole.position.set(x + 6, 5, z + 6); scene.add(pole); const light = new THREE.Mesh(lightGeometry, new THREE.MeshPhongMaterial({ color: 0xff0000 })); light.position.set(x + 6, 10, z + 6); trafficLights.push({ mesh: light, state: 'red', timer: 0, position: new THREE.Vector3(x + 6, 0, z + 6) }); scene.add(light); } } // Parks const grassTexture = textureLoader.load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg'); const parkMaterial = new THREE.MeshPhongMaterial({ map: grassTexture }); const parkGeometry = new THREE.PlaneGeometry(20, 20); const treeTrunkMaterial = new THREE.MeshPhongMaterial({ color: 0x8b4513 }); const treeTrunkGeometry = new THREE.CylinderGeometry(0.5, 0.5, 3); const treeFoliageMaterial = new THREE.MeshPhongMaterial({ color: 0x228b22 }); const treeFoliageGeometry = new THREE.SphereGeometry(2); const pathMaterial = new THREE.MeshPhongMaterial({ color: 0xaaaaaa }); const pathGeometry = new THREE.PlaneGeometry(2, 20); const benchMaterial = new THREE.MeshPhongMaterial({ color: 0x654321 }); const benchGeometry = new THREE.BoxGeometry(1, 0.5, 2); const parkPositions = [[-60, -60], [60, 60], [-60, 60], [60, -60]]; parkPositions.forEach(([x, z]) => { const park = new THREE.Mesh(parkGeometry, parkMaterial); park.rotation.x = -Math.PI / 2; park.position.set(x, 0.01, z); scene.add(park); const pathV = new THREE.Mesh(pathGeometry, pathMaterial); pathV.rotation.x = -Math.PI / 2; pathV.position.set(x, 0.02, z); scene.add(pathV); const pathH = new THREE.Mesh(pathGeometry, pathMaterial); pathH.rotation.x = -Math.PI / 2; pathH.rotation.z = Math.PI / 2; pathH.position.set(x, 0.02, z); scene.add(pathH); for (let i = 0; i < 6; i++) { const tx = x + Math.random() * 8 - 4; const tz = z + Math.random() * 8 - 4; const trunk = new THREE.Mesh(treeTrunkGeometry, treeTrunkMaterial); trunk.position.set(tx, 1.5, tz); scene.add(trunk); const foliage = new THREE.Mesh(treeFoliageGeometry, treeFoliageMaterial); foliage.position.set(tx, 4, tz); scene.add(foliage); } const bench1 = new THREE.Mesh(benchGeometry, benchMaterial); bench1.position.set(x + 5, 0.25, z + 5); scene.add(bench1); const bench2 = new THREE.Mesh(benchGeometry, benchMaterial); bench2.position.set(x - 5, 0.25, z - 5); scene.add(bench2); }); // Ramps const rampTexture = textureLoader.load('https://threejs.org/examples/textures/crate.gif'); const rampMaterial = new THREE.MeshPhongMaterial({ map: rampTexture }); const rampGeometry = new THREE.BoxGeometry(10, 0.5, 4); const ramps = [ new THREE.Mesh(rampGeometry, rampMaterial), new THREE.Mesh(rampGeometry, rampMaterial) ]; ramps[0].position.set(20, 0.25, 40); ramps[0].rotation.x = Math.PI / 6; ramps[1].position.set(-30, 0.25, -50); ramps[1].rotation.x = Math.PI / 6; ramps.forEach(r => scene.add(r)); // Traffic cars const trafficCarTexture = textureLoader.load('https://threejs.org/examples/textures/uv_grid_opengl.jpg'); const trafficCarMaterial = new THREE.MeshPhongMaterial({ map: trafficCarTexture }); const trafficCarGeometry = new THREE.BoxGeometry(2, 1, 4); const trafficCars = [ { mesh: new THREE.Mesh(trafficCarGeometry, trafficCarMaterial), speed: 0.1, direction: 1 }, { mesh: new THREE.Mesh(trafficCarGeometry, trafficCarMaterial), speed: 0.1, direction: -1 } ]; trafficCars[0].mesh.position.set(15, 0.5, -20); trafficCars[1].mesh.position.set(-15, 0.5, 30); trafficCars.forEach(c => scene.add(c.mesh)); // Camera and Controls camera.position.set(0, 10, 15); camera.lookAt(car.position); const controls = { keys: { w: false, a: false, s: false, d: false } }; document.addEventListener('keydown', (event) => { switch(event.key.toLowerCase()) { case 'w': controls.keys.w = true; break; case 'a': controls.keys.a = true; break; case 's': controls.keys.s = true; break; case 'd': controls.keys.d = true; break; } }); document.addEventListener('keyup', (event) => { switch(event.key.toLowerCase()) { case 'w': controls.keys.w = false; break; case 'a': controls.keys.a = false; break; case 's': controls.keys.s = false; break; case 'd': controls.keys.d = false; break; } }); // Collision detection and response function checkCollision(obj1, obj2) { const box1 = new THREE.Box3().setFromObject(obj1); const box2 = new THREE.Box3().setFromObject(obj2); return box1.intersectsBox(box2); } function resolveCollision(car, obstacle) { const carBox = new THREE.Box3().setFromObject(car); const obsBox = new THREE.Box3().setFromObject(obstacle); const direction = car.position.clone().sub(obstacle.position).normalize(); const penetration = Math.min( Math.abs(carBox.max.x - obsBox.min.x), Math.abs(carBox.min.x - obsBox.max.x), Math.abs(carBox.max.z - obsBox.min.z), Math.abs(carBox.min.z - obsBox.max.z) ); carPhysics.speed *= -0.5; car.position.add(direction.multiplyScalar(penetration * 0.5)); } // Game loop function animate() { requestAnimationFrame(animate); // Car physics let newSpeed = carPhysics.speed; if (controls.keys.w) newSpeed = Math.min(newSpeed + carPhysics.acceleration, carPhysics.maxSpeed); if (controls.keys.s) newSpeed = Math.max(newSpeed - carPhysics.acceleration, -carPhysics.maxSpeed/2); if (controls.keys.a) car.rotation.y += carPhysics.turnSpeed * (carPhysics.onGround ? 1 : 0.5); if (controls.keys.d) car.rotation.y -= carPhysics.turnSpeed * (carPhysics.onGround ? 1 : 0.5); newSpeed *= carPhysics.friction; carPhysics.velocityY -= carPhysics.gravity; car.position.y += carPhysics.velocityY; if (car.position.y <= 0.5) { car.position.y = 0.5; carPhysics.velocityY = 0; carPhysics.onGround = true; } else { carPhysics.onGround = false; } ramps.forEach(ramp => { if (checkCollision(car, ramp) && carPhysics.onGround) { carPhysics.velocityY = Math.abs(newSpeed) * 0.5; } }); const newX = car.position.x + Math.sin(car.rotation.y) * newSpeed; const newZ = car.position.z + Math.cos(car.rotation.y) * newSpeed; const tempCar = car.clone(); tempCar.position.set(newX, car.position.y, newZ); let canMove = true; buildings.forEach(building => { if (checkCollision(tempCar, building)) { resolveCollision(car, building); canMove = false; } }); trafficCars.forEach(tc => { if (checkCollision(tempCar, tc.mesh)) { resolveCollision(car, tc.mesh); canMove = false; } }); if (canMove) { carPhysics.speed = newSpeed; car.position.x = newX; car.position.z = newZ; } // Traffic movement with light interaction trafficCars.forEach(tc => { let canMove = true; trafficLights.forEach(light => { const dist = tc.mesh.position.distanceTo(light.position); if (dist < 10 && light.state === 'red') { canMove = false; } }); if (canMove) { tc.mesh.position.z += tc.speed * tc.direction; if (tc.mesh.position.z > 100) tc.mesh.position.z = -100; if (tc.mesh.position.z < -100) tc.mesh.position.z = 100; } }); // Traffic light cycle trafficLights.forEach(light => { light.timer++; if (light.timer > 200) { light.timer = 0; light.state = light.state === 'red' ? 'green' : 'red'; light.mesh.material.color.setHex(light.state === 'red' ? 0xff0000 : 0x00ff00); } }); // Camera follow camera.position.x = car.position.x + Math.sin(car.rotation.y) * -15; camera.position.z = car.position.z + Math.cos(car.rotation.y) * -15; camera.position.y = car.position.y + 10; camera.lookAt(car.position); renderer.render(scene, camera); } window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }); animate(); </script> </body> </html>
